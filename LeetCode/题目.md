### [1、反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

#### 示例 1：

```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

#### 示例 2：

```
输入：s = ["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

#### 提示：

- `1 <= s.length <= 105`
- `s[i]` 都是 ASCII 码表中的可打印字符

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/reverse-string
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### [2、判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

#### 示例 1：

```
输入: s = "leetcode"
输出: false 
```

#### 示例 2：

```
输入: s = "abc"
输出: true
```

#### 限制：

- `0 <= len(s) <= 100`
- 如果你不使用额外的数据结构，会很加分。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/is-unique-lcci
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路

1. 利用标记数组实现
   若为ASCII字符集，定义一个128位的数组，用字符的值作为数组的下标。出现一次自增1，当某一位大于1时，则表示该字符出现2次，则返回`false`，否则返回`ture`；

   ```c
   bool isUnique(char *astr)
   {
       int ascii[128] = {0};
       for (int i = 0; i < strlen(astr); i++)
       {
           if ((++ascii[astr[i]]) >1 )
               return false;
       }
       return true;
   }
   ```

2. 位运算
   若为ASCII字符集，用128个bit运算。0表示未出现，1表示出现一次。当某一字符出现第二次时，该字符对应的位上为1，则返回false。