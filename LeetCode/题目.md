### [1、反转字符串](https://leetcode-cn.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

#### 示例 1：

> 输入：s = ["h","e","l","l","o"]
>
> 输出：["o","l","l","e","h"]

#### 示例 2：

> 输入：s = ["H","a","n","n","a","h"]
>
> 输出：["h","a","n","n","a","H"]

#### 提示：

- `1 <= s.length <= 105`
- `s[i]` 都是 ASCII 码表中的可打印字符

> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/reverse-string
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### [2、判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

#### 示例 1：

> 输入: s = "leetcode"
>
> 输出: false 

#### 示例 2：

> 输入: s = "abc"
>
> 输出: true

#### 限制：

- `0 <= len(s) <= 100`
- 如果你不使用额外的数据结构，会很加分。

> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/is-unique-lcci
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 解题思路

1. 利用标记数组实现
   若为ASCII字符集，定义一个128位的数组，用字符的值作为数组的下标。出现一次自增1，当某一位大于1时，则表示该字符出现2次，则返回`false`，否则返回`ture`；

   ```c
   bool isUnique(char *astr)
   {
       int ascii[128] = {0};
       for (int i = 0; i < strlen(astr); i++)
       {
           if ((++ascii[astr[i]]) >1 )
               return false;
       }
       return true;
   }
   ```

2. 位运算
   若为ASCII字符集，用128个bit运算。0表示未出现，1表示出现一次。当某一字符出现第二次时，该字符对应的位上为1，则返回false。

3. 双循环
   逐个字符比较。

4. 排序加遍历
   排序完相同的字符相邻，比较相邻的两个字符。

### [3、字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

#### 函数 `myAtoi(string s)` 的算法如下：

- 读入字符串并丢弃无用的前导空格
- 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
- 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
- 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
- 如果整数数超过 32 位有符号整数范围 $[-2^{31},2^{31}-1]$，需要截断这个整数，使其保持在这个范围内。具体来说，小于 $-2^{31}$ 的整数应该被固定为$-2^{31}$ ，大于 $2^{31}-1$ 的整数应该被固定为  $2^{31}-1$ 。
- 返回整数作为最终结果。

#### 注意：

- 本题中的空白字符只包括空格字符 `' '` 。

- 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。

#### 示例 1：

> 输入：s = "42"
>
> 输出：42
>
> 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
>
> 第 1 步："42"（当前没有读入字符，因为没有前导空格）
>
> ​         ^
>
> 第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
>
> ​         ^
>
> 第 3 步："42"（读入 "42"）
>
> ​           ^
>
> 解析得到整数 42 。
>
> 由于 "42" 在范围  $[-2^{31},2^{31}-1]$ 内，最终结果为 42 。

#### 示例 2：

> 输入：s = "   -42"
>
> 输出：-42
>
> 解释：
>
> 第 1 步："   -42"（读入前导空格，但忽视掉）
>
> ​            ^
>
> 第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
>
> ​             ^
>
> 第 3 步："   -42"（读入 "42"）
>
> ​               ^
>
> 解析得到整数 -42 。
>
> 由于 "-42" 在范围  $[-2^{31},2^{31}-1]$ 内，最终结果为 -42 。

#### 示例 3：

> 输入：s = "4193 with words"
>
> 输出：4193
>
> 解释：
>
> 第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
>
> ​         ^
>
> 第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
>
> ​         ^
>
> 第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
>
> ​             ^
>
> 解析得到整数 4193 。
>
> 由于 "4193" 在范围  $[-2^{31},2^{31}-1]$ 内，最终结果为 4193 。
>
> 

#### 示例 4：

> 输入：s = "words and 987"
>
> 输出：0
>
> 解释：
>
> 第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
>
> ​         ^
>
> 第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
>
> ​         ^
>
> 第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
>
> ​         ^
> 解析得到整数 0 ，因为没有读入任何数字。
>
> 由于 0 在范围  $[-2^{31},2^{31}-1]$ 内，最终结果为 0 。

#### 示例 5：

> 输入：s = "-91283472332"
>
> 输出：-2147483648
>
> 解释：
>
> 第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）
>
> ​         ^
>
> 第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）
>
> ​          ^
>
> 第 3 步："-91283472332"（读入 "91283472332"）
>
> ​                     ^
>
> 解析得到整数 -91283472332 。
>
> 由于 -91283472332 小于范围  $[-2^{31},2^{31}-1]$ 的下界，最终结果被截断为$-2^{31}$= -2147483648 。

#### 提示：

- `0 <= s.length <= 200`
- `s` 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成

> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/string-to-integer-atoi
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### [4、两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target`  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

#### 示例 1：

> 输入：nums = [2,7,11,15], target = 9
>
> 输出：[0,1]
>
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

#### 示例 2：

> 输入：nums = [3,2,4], target = 6
>
> 输出：[1,2]
>
> 示例 3：
>
> 输入：nums = [3,3], target = 6
>
> 输出：[0,1]

#### 提示：

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- 只会存在一个有效答案

#### 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？

> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/two-sum
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### [5、两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

#### 示例 1：

> 输入：l1 = [2,4,3], l2 = [5,6,4]
>
> 输出：[7,0,8]
>
> 解释：342 + 465 = 807.

#### 示例 2：

> 输入：l1 = [0], l2 = [0]
>
> 输出：[0]

#### 示例 3：

> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
>
> 输出：[8,9,9,9,0,0,0,1]

#### 提示：

- 每个链表中的节点数在范围 `[1, 100]` 内

- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/add-two-numbers
>
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。